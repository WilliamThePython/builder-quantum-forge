import * as THREE from 'three';

/**
 * Format conversion utilities for STL, OBJ, and GLB formats
 */
export class FormatConverter {
  
  /**
   * Convert Three.js BufferGeometry to OBJ format string
   */
  static geometryToOBJ(geometry: THREE.BufferGeometry, name: string = 'model'): string {
    const positions = geometry.attributes.position;
    const normals = geometry.attributes.normal;
    const uvs = geometry.attributes.uv;
    
    let objContent = `# Generated by STL Viewer Platform\n`;
    objContent += `# Object: ${name}\n\n`;
    objContent += `o ${name}\n\n`;

    // Write vertices
    for (let i = 0; i < positions.count; i++) {
      const x = positions.getX(i);
      const y = positions.getY(i);
      const z = positions.getZ(i);
      objContent += `v ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}\n`;
    }
    
    objContent += '\n';

    // Write normals if available
    if (normals) {
      for (let i = 0; i < normals.count; i++) {
        const nx = normals.getX(i);
        const ny = normals.getY(i);
        const nz = normals.getZ(i);
        objContent += `vn ${nx.toFixed(6)} ${ny.toFixed(6)} ${nz.toFixed(6)}\n`;
      }
      objContent += '\n';
    }

    // Write texture coordinates if available
    if (uvs) {
      for (let i = 0; i < uvs.count; i++) {
        const u = uvs.getX(i);
        const v = uvs.getY(i);
        objContent += `vt ${u.toFixed(6)} ${v.toFixed(6)}\n`;
      }
      objContent += '\n';
    }

    // Write faces
    const triangleCount = positions.count / 3;
    for (let i = 0; i < triangleCount; i++) {
      const i3 = i * 3;
      const v1 = i3 + 1; // OBJ indices start at 1
      const v2 = i3 + 2;
      const v3 = i3 + 3;

      if (normals && uvs) {
        objContent += `f ${v1}/${v1}/${v1} ${v2}/${v2}/${v2} ${v3}/${v3}/${v3}\n`;
      } else if (normals) {
        objContent += `f ${v1}//${v1} ${v2}//${v2} ${v3}//${v3}\n`;
      } else if (uvs) {
        objContent += `f ${v1}/${v1} ${v2}/${v2} ${v3}/${v3}\n`;
      } else {
        objContent += `f ${v1} ${v2} ${v3}\n`;
      }
    }

    return objContent;
  }

  /**
   * Parse OBJ format string to Three.js BufferGeometry
   */
  static objToGeometry(objContent: string): THREE.BufferGeometry {
    const geometry = new THREE.BufferGeometry();
    
    const vertices: number[] = [];
    const normals: number[] = [];
    const uvs: number[] = [];
    const faces: Array<{
      vertices: number[];
      normals?: number[];
      uvs?: number[];
    }> = [];

    const lines = objContent.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;

      const parts = trimmed.split(/\s+/);
      const command = parts[0];

      switch (command) {
        case 'v': // Vertex
          vertices.push(
            parseFloat(parts[1]),
            parseFloat(parts[2]),
            parseFloat(parts[3])
          );
          break;

        case 'vn': // Normal
          normals.push(
            parseFloat(parts[1]),
            parseFloat(parts[2]),
            parseFloat(parts[3])
          );
          break;

        case 'vt': // Texture coordinate
          uvs.push(
            parseFloat(parts[1]),
            parseFloat(parts[2])
          );
          break;

        case 'f': // Face
          const face: any = { vertices: [] };
          
          for (let i = 1; i < parts.length; i++) {
            const vertex = parts[i].split('/');
            face.vertices.push(parseInt(vertex[0]) - 1); // Convert to 0-based index
            
            if (vertex[1] && uvs.length > 0) {
              if (!face.uvs) face.uvs = [];
              face.uvs.push(parseInt(vertex[1]) - 1);
            }
            
            if (vertex[2] && normals.length > 0) {
              if (!face.normals) face.normals = [];
              face.normals.push(parseInt(vertex[2]) - 1);
            }
          }
          
          faces.push(face);
          break;
      }
    }

    // Build geometry arrays
    const positionArray: number[] = [];
    const normalArray: number[] = [];
    const uvArray: number[] = [];

    for (const face of faces) {
      // Triangulate face if it has more than 3 vertices
      for (let i = 1; i < face.vertices.length - 1; i++) {
        const indices = [0, i, i + 1];
        
        for (const idx of indices) {
          const vertexIndex = face.vertices[idx];
          positionArray.push(
            vertices[vertexIndex * 3],
            vertices[vertexIndex * 3 + 1],
            vertices[vertexIndex * 3 + 2]
          );

          if (face.normals && face.normals[idx] !== undefined) {
            const normalIndex = face.normals[idx];
            normalArray.push(
              normals[normalIndex * 3],
              normals[normalIndex * 3 + 1],
              normals[normalIndex * 3 + 2]
            );
          }

          if (face.uvs && face.uvs[idx] !== undefined) {
            const uvIndex = face.uvs[idx];
            uvArray.push(
              uvs[uvIndex * 2],
              uvs[uvIndex * 2 + 1]
            );
          }
        }
      }
    }

    // Set geometry attributes
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positionArray), 3));
    
    if (normalArray.length > 0) {
      geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normalArray), 3));
    } else {
      geometry.computeVertexNormals();
    }
    
    if (uvArray.length > 0) {
      geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvArray), 2));
    }

    return geometry;
  }

  /**
   * Convert Three.js BufferGeometry to GLB format
   */
  static async geometryToGLB(geometry: THREE.BufferGeometry, name: string = 'model'): Promise<ArrayBuffer> {
    // Import GLTFExporter dynamically
    const { GLTFExporter } = await import('three/examples/jsm/exporters/GLTFExporter');
    
    // Create a mesh from the geometry
    const material = new THREE.MeshStandardMaterial({ color: 0x606060 });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.name = name;

    // Create a scene
    const scene = new THREE.Scene();
    scene.add(mesh);

    // Export to GLB
    const exporter = new GLTFExporter();
    
    return new Promise((resolve, reject) => {
      exporter.parse(
        scene,
        (result) => {
          if (result instanceof ArrayBuffer) {
            resolve(result);
          } else {
            reject(new Error('GLB export failed - unexpected result type'));
          }
        },
        (error) => {
          reject(error);
        },
        {
          binary: true,
          includeCustomExtensions: false,
          animations: [],
          truncateDrawRange: true,
          embedImages: true,
          forcePowerOfTwoTextures: false,
          maxTextureSize: 1024
        }
      );
    });
  }

  /**
   * Get file extension and MIME type for format
   */
  static getFormatInfo(format: 'stl' | 'obj' | 'glb'): {
    extension: string;
    mimeType: string;
    description: string;
  } {
    switch (format) {
      case 'stl':
        return {
          extension: '.stl',
          mimeType: 'application/sla',
          description: 'STL - 3D printing format'
        };
      case 'obj':
        return {
          extension: '.obj',
          mimeType: 'application/object',
          description: 'OBJ - Wavefront 3D object'
        };
      case 'glb':
        return {
          extension: '.glb',
          mimeType: 'model/gltf-binary',
          description: 'GLB - Binary glTF format'
        };
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }

  /**
   * Download content as file
   */
  static downloadFile(
    content: string | ArrayBuffer,
    filename: string,
    mimeType: string
  ): void {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up URL
    setTimeout(() => URL.revokeObjectURL(url), 100);
  }

  /**
   * Create optimized OBJ from STL geometry for manipulation
   */
  static createManipulationOBJ(geometry: THREE.BufferGeometry): string {
    // Ensure geometry has proper attributes for manipulation
    if (!geometry.attributes.normal) {
      geometry.computeVertexNormals();
    }
    
    // Compute bounding box for reference
    geometry.computeBoundingBox();
    
    return this.geometryToOBJ(geometry, 'manipulation_model');
  }

  /**
   * Validate OBJ content
   */
  static validateOBJ(objContent: string): {
    isValid: boolean;
    vertexCount: number;
    faceCount: number;
    errors: string[];
  } {
    const errors: string[] = [];
    let vertexCount = 0;
    let faceCount = 0;

    const lines = objContent.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;

      const parts = trimmed.split(/\s+/);
      const command = parts[0];

      switch (command) {
        case 'v':
          if (parts.length !== 4) {
            errors.push(`Invalid vertex line: ${trimmed}`);
          } else {
            vertexCount++;
          }
          break;

        case 'f':
          if (parts.length < 4) {
            errors.push(`Invalid face line: ${trimmed}`);
          } else {
            faceCount++;
          }
          break;
      }
    }

    return {
      isValid: errors.length === 0 && vertexCount > 0 && faceCount > 0,
      vertexCount,
      faceCount,
      errors
    };
  }
}

/**
 * Enhanced export options interface
 */
export interface ExportOptions {
  format: 'stl' | 'obj' | 'glb';
  filename?: string;
  scale?: number;
  centered?: boolean;
  includeNormals?: boolean;
  precision?: number;
}

/**
 * Multi-format exporter
 */
export class MultiFormatExporter {
  
  /**
   * Export geometry in specified format
   */
  static async exportGeometry(
    geometry: THREE.BufferGeometry,
    options: ExportOptions
  ): Promise<void> {
    const {
      format,
      filename,
      scale = 1,
      centered = true,
      includeNormals = true,
      precision = 6
    } = options;

    // Clone and prepare geometry
    const exportGeometry = geometry.clone();
    
    if (scale !== 1) {
      exportGeometry.scale(scale, scale, scale);
    }
    
    if (centered) {
      exportGeometry.computeBoundingBox();
      if (exportGeometry.boundingBox) {
        const center = exportGeometry.boundingBox.getCenter(new THREE.Vector3());
        exportGeometry.translate(-center.x, -center.y, -center.z);
      }
    }
    
    if (includeNormals && !exportGeometry.attributes.normal) {
      exportGeometry.computeVertexNormals();
    }

    const formatInfo = FormatConverter.getFormatInfo(format);
    const exportFilename = filename || `export${formatInfo.extension}`;

    try {
      switch (format) {
        case 'stl':
          const { exportCurrentSTL } = await import('./stlExporter');
          exportCurrentSTL(exportGeometry, exportFilename);
          break;
          
        case 'obj':
          const objContent = FormatConverter.geometryToOBJ(exportGeometry);
          FormatConverter.downloadFile(objContent, exportFilename, formatInfo.mimeType);
          break;
          
        case 'glb':
          const glbBuffer = await FormatConverter.geometryToGLB(exportGeometry);
          FormatConverter.downloadFile(glbBuffer, exportFilename, formatInfo.mimeType);
          break;
          
        default:
          throw new Error(`Unsupported export format: ${format}`);
      }
      
      console.log(`Successfully exported ${format.toUpperCase()} file: ${exportFilename}`);
      
    } catch (error) {
      console.error(`Failed to export ${format.toUpperCase()}:`, error);
      throw error;
    } finally {
      exportGeometry.dispose();
    }
  }
}
